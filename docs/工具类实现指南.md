# å·¥å…·ç±»å®ç°æŒ‡å—

## ğŸ”§ JWT å·¥å…·ç±»å®ç°æç¤º

### å½“å‰é—®é¢˜åˆ†æ

ä½ çš„ `JwtUtil.cc` ä¸­æœ‰å‡ ä¸ªé—®é¢˜ï¼š

1. å‡½æ•°å£°æ˜é‡å¤äº†ï¼ˆ`.h` å·²ç»å£°æ˜ï¼Œ`.cc` ä¸éœ€è¦å†å£°æ˜ï¼‰
2. `.cc` æ–‡ä»¶ä¸­ç¼ºå°‘ `#include` å¿…è¦çš„å¤´æ–‡ä»¶
3. å‡½æ•°æ²¡æœ‰å®ç°ä½“

### å®ç°æ–¹æ¡ˆé€‰æ‹©

**æ–¹æ¡ˆ1ï¼šä½¿ç”¨ jwt-cpp åº“ï¼ˆæ¨èï¼Œç®€å•ï¼‰**

éœ€è¦å…ˆåœ¨ CMakeLists.txt ä¸­æ·»åŠ ï¼š

```cmake
# åœ¨ CMakeLists.txt ä¸­æ·»åŠ 
include(FetchContent)
FetchContent_Declare(
    jwt-cpp
    GIT_REPOSITORY https://github.com/Thalhammer/jwt-cpp.git
    GIT_TAG master
)
FetchContent_MakeAvailable(jwt-cpp)
```

**æ–¹æ¡ˆ2ï¼šæ‰‹åŠ¨å®ç°ï¼ˆå­¦ä¹ ä»·å€¼é«˜ï¼Œä½†å¤æ‚ï¼‰**

å¦‚æœä¸æƒ³å¼•å…¥å¤–éƒ¨åº“ï¼Œå¯ä»¥ç”¨ OpenSSL æ‰‹åŠ¨å®ç° JWTã€‚

---

### JwtUtil.cc å®ç°æ¡†æ¶ï¼ˆä½¿ç”¨ jwt-cppï¼‰

```cpp
#include "JwtUtil.h"
#include <jwt-cpp/jwt.h>
#include <ctime>
#include <sstream>

std::string JwtUtil::generateToken(int userId, const std::string& secret, int expiresIn) {
    // 1. è®¡ç®—è¿‡æœŸæ—¶é—´æˆ³ï¼ˆå½“å‰æ—¶é—´ + expiresIn ç§’ï¼‰
    auto now = std::chrono::system_clock::now();
    auto exp = now + std::chrono::seconds(expiresIn);
    
    // 2. åˆ›å»º payloadï¼ˆåŒ…å« user_id å’Œ expï¼‰
    auto token = jwt::create()
        .set_type("JWT")
        .set_issued_at(now)
        .set_expires_at(exp)
        .set_payload_claim("user_id", jwt::claim(std::to_string(userId)))
        .sign(jwt::algorithm::hs256{secret});
    
    return token;
}

bool JwtUtil::verifyToken(const std::string& token, const std::string& secret) {
    try {
        // éªŒè¯å¹¶è§£ç  token
        auto decoded = jwt::decode(token);
        
        // éªŒè¯ç­¾å
        auto verifier = jwt::verify()
            .allow_algorithm(jwt::algorithm::hs256{secret})
            .with_issuer("your-app-name");  // å¯é€‰
        
        verifier.verify(decoded);
        return true;
    } catch (const std::exception& e) {
        // token æ— æ•ˆæˆ–å·²è¿‡æœŸ
        return false;
    }
}

int JwtUtil::getUserIdFromToken(const std::string& token) {
    try {
        auto decoded = jwt::decode(token);
        auto claims = decoded.get_payload_claims();
        
        if (claims.find("user_id") != claims.end()) {
            std::string userIdStr = claims["user_id"].as_string();
            return std::stoi(userIdStr);
        }
        return -1;  // æœªæ‰¾åˆ° user_id
    } catch (const std::exception& e) {
        return -1;  // è§£æå¤±è´¥
    }
}
```

### JwtUtil.cc å®ç°æ¡†æ¶ï¼ˆæ‰‹åŠ¨å®ç° - OpenSSLï¼‰

å¦‚æœä½ é€‰æ‹©æ‰‹åŠ¨å®ç°ï¼Œéœ€è¦ï¼š

1. Base64URL ç¼–ç /è§£ç 
2. HMAC-SHA256 ç­¾å
3. JSON åˆ›å»ºå’Œè§£æï¼ˆå¯ä»¥ç”¨ jsoncppï¼‰

è¿™ä¼šæ›´å¤æ‚ï¼Œå»ºè®®å…ˆç”¨ jwt-cpp åº“ï¼Œç†è§£åŸç†åå†è€ƒè™‘æ‰‹åŠ¨å®ç°ã€‚

---

## ğŸ” å¯†ç å·¥å…·ç±»å®ç°æç¤º

### PasswordUtils.h æ¡†æ¶

```cpp
#pragma once
#include <string>

class PasswordUtils {
public:
    // å“ˆå¸Œå¯†ç ï¼ˆè¿”å›å“ˆå¸Œå€¼å­—ç¬¦ä¸²ï¼‰
    static std::string hashPassword(const std::string& plainPassword);
    
    // éªŒè¯å¯†ç ï¼ˆæ˜æ–‡å¯†ç  vs å­˜å‚¨çš„å“ˆå¸Œå€¼ï¼‰
    static bool verifyPassword(const std::string& plainPassword, const std::string& hash);
    
private:
    // ç”Ÿæˆéšæœºç›ï¼ˆå¯é€‰ï¼Œå¦‚æœä¸ç”¨ BCryptï¼‰
    static std::string generateSalt(int length = 16);
};
```

### å®ç°æ–¹æ¡ˆé€‰æ‹©

**æ–¹æ¡ˆ1ï¼šä½¿ç”¨ libbcryptï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰**

```cpp
#include "PasswordUtils.h"
#include <bcrypt/bcrypt.h>  // éœ€è¦å®‰è£… libbcrypt-dev

std::string PasswordUtils::hashPassword(const std::string& plainPassword) {
    char hash[BCRYPT_HASHSIZE];
    bcrypt_hashpw(plainPassword.c_str(), hash);
    return std::string(hash);
}

bool PasswordUtils::verifyPassword(const std::string& plainPassword, const std::string& hash) {
    return bcrypt_checkpw(plainPassword.c_str(), hash.c_str()) == 0;
}
```

**æ–¹æ¡ˆ2ï¼šä½¿ç”¨ OpenSSL + SHA-256 + éšæœºç›ï¼ˆæ¨èï¼Œä¸éœ€è¦é¢å¤–åº“ï¼‰**

```cpp
#include "PasswordUtils.h"
#include <openssl/sha.h>
#include <openssl/rand.h>
#include <sstream>
#include <iomanip>

std::string PasswordUtils::generateSalt(int length) {
    unsigned char salt[length];
    RAND_bytes(salt, length);
    
    std::stringstream ss;
    for (int i = 0; i < length; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)salt[i];
    }
    return ss.str();
}

std::string PasswordUtils::hashPassword(const std::string& plainPassword) {
    // ç”Ÿæˆéšæœºç›
    std::string salt = generateSalt(16);
    
    // SHA-256 å“ˆå¸Œï¼špassword + salt
    unsigned char hash[SHA256_DIGEST_LENGTH];
    std::string input = plainPassword + salt;
    SHA256((unsigned char*)input.c_str(), input.length(), hash);
    
    // å°†å“ˆå¸Œå€¼å’Œç›ç¼–ç ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
    }
    
    // è¿”å›æ ¼å¼ï¼š$sha256$salt$hash
    return "$sha256$" + salt + "$" + ss.str();
}

bool PasswordUtils::verifyPassword(const std::string& plainPassword, const std::string& hash) {
    // è§£æå­˜å‚¨çš„å“ˆå¸Œæ ¼å¼ï¼š$sha256$salt$hash
    if (hash.substr(0, 8) != "$sha256$") {
        return false;
    }
    
    // æå– salt å’Œ storedHash
    size_t saltStart = 8;
    size_t saltEnd = hash.find('$', saltStart);
    if (saltEnd == std::string::npos) {
        return false;
    }
    
    std::string salt = hash.substr(saltStart, saltEnd - saltStart);
    std::string storedHash = hash.substr(saltEnd + 1);
    
    // é‡æ–°è®¡ç®—å“ˆå¸Œ
    unsigned char computedHash[SHA256_DIGEST_LENGTH];
    std::string input = plainPassword + salt;
    SHA256((unsigned char*)input.c_str(), input.length(), computedHash);
    
    // è½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä¸²
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)computedHash[i];
    }
    
    // æ¯”è¾ƒ
    return ss.str() == storedHash;
}
```

---

## ğŸ’¾ æ•°æ®åº“å·¥å…·ç±»å®ç°æç¤º

### DbUtils.h æ¡†æ¶

```cpp
#pragma once
#include <drogon/orm/DbClient.h>
#include <functional>
#include <memory>

class DbUtils {
public:
    // è·å–æ•°æ®åº“å®¢æˆ·ç«¯ï¼ˆè¿æ¥æ± ï¼‰
    static drogon::orm::DbClientPtr getDbClient();
    
    // æ‰§è¡ŒæŸ¥è¯¢ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…å¯ä»¥å°è£…æ›´å¤šä¾¿æ·å‡½æ•°ï¼‰
    // è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œä½ å¯ä»¥æ ¹æ®éœ€æ±‚æ‰©å±•
};
```

### DbUtils.cc å®ç°

```cpp
#include "DbUtils.h"
#include <drogon/drogon.h>

drogon::orm::DbClientPtr DbUtils::getDbClient() {
    // Drogon ä¼šè‡ªåŠ¨ç®¡ç†è¿æ¥æ± ï¼Œç›´æ¥ä» app è·å–å³å¯
    return drogon::app().getDbClient();
}
```

### é«˜çº§ç”¨æ³•ï¼šå°è£…å¸¸ç”¨æŸ¥è¯¢å‡½æ•°

å¦‚æœä½ æƒ³è¦æ›´é«˜çº§çš„å°è£…ï¼Œå¯ä»¥æ·»åŠ ï¼š

```cpp
// DbUtils.h æ‰©å±•
class DbUtils {
public:
    // æŸ¥è¯¢å•ä¸ªç”¨æˆ·ï¼ˆå¼‚æ­¥ï¼‰
    static void getUserByEmail(const std::string& email,
                               std::function<void(const drogon::orm::Result&)> successCallback,
                               std::function<void(const drogon::orm::DrogonDbException&)> errorCallback);
    
    // åˆ›å»ºç”¨æˆ·ï¼ˆå¼‚æ­¥ï¼‰
    static void createUser(const std::string& email, 
                          const std::string& passwordHash,
                          const std::string& role,
                          std::function<void(int userId)> successCallback,
                          std::function<void(const drogon::orm::DrogonDbException&)> errorCallback);
};
```

```cpp
// DbUtils.cc å®ç°
#include "DbUtils.h"
#include <drogon/drogon.h>

void DbUtils::getUserByEmail(const std::string& email,
                             std::function<void(const drogon::orm::Result&)> successCallback,
                             std::function<void(const drogon::orm::DrogonDbException&)> errorCallback) {
    auto db = getDbClient();
    db->execSqlAsync(
        "SELECT id, email, password_hash, role FROM \"user\" WHERE email = $1",
        successCallback,
        errorCallback,
        email
    );
}

void DbUtils::createUser(const std::string& email,
                        const std::string& passwordHash,
                        const std::string& role,
                        std::function<void(int userId)> successCallback,
                        std::function<void(const drogon::orm::DrogonDbException&)> errorCallback) {
    auto db = getDbClient();
    db->execSqlAsync(
        "INSERT INTO \"user\" (email, password_hash, role) VALUES ($1, $2, $3) RETURNING id",
        [successCallback](const drogon::orm::Result& r) {
            if (!r.empty()) {
                int userId = r[0]["id"].as<int>();
                successCallback(userId);
            }
        },
        errorCallback,
        email,
        passwordHash,
        role
    );
}
```

---

## ğŸ“ æ›´æ–° CMakeLists.txt

éœ€è¦æ·»åŠ å·¥å…·ç±»æ–‡ä»¶åˆ°ç¼–è¯‘åˆ—è¡¨ï¼š

```cmake
# åœ¨ CMakeLists.txt çš„ set(ALL_SOURCES ...) éƒ¨åˆ†æ·»åŠ ï¼š
set(ALL_SOURCES
    src/main.cpp
    src/controllers/HealthController.h
    src/controllers/HealthController.cc
    src/utils/JwtUtil.h
    src/utils/JwtUtil.cc
    src/utils/PasswordUtils.h
    src/utils/PasswordUtils.cc
    src/utils/DbUtils.h
    src/utils/DbUtils.cc
)
```

---

## âš ï¸ å¸¸è§é—®é¢˜

### 1. ç¼–è¯‘é”™è¯¯ï¼š"æ‰¾ä¸åˆ° jwt-cpp"

**è§£å†³æ–¹æ¡ˆï¼š**

- å¦‚æœä½¿ç”¨ jwt-cppï¼Œç¡®ä¿ CMakeLists.txt ä¸­æ­£ç¡®æ·»åŠ äº† FetchContent
- æˆ–è€…æ‰‹åŠ¨å®‰è£…ï¼š`sudo apt install libjwt-dev`ï¼ˆå¦‚æœå¯ç”¨ï¼‰

### 2. ç¼–è¯‘é”™è¯¯ï¼š"æ‰¾ä¸åˆ° openssl/sha.h"

**è§£å†³æ–¹æ¡ˆï¼š**

```bash
sudo apt install libssl-dev
```

ç„¶ååœ¨ CMakeLists.txt ä¸­å·²ç»é“¾æ¥äº† `ssl` å’Œ `crypto`ï¼Œåº”è¯¥æ²¡é—®é¢˜ã€‚

### 3. JWT token ç”ŸæˆåéªŒè¯å¤±è´¥

**æ£€æŸ¥ç‚¹ï¼š**

- secret å¿…é¡»ä¸€è‡´
- æ—¶é—´æˆ³è®¡ç®—æ˜¯å¦æ­£ç¡®ï¼ˆæ³¨æ„æ—¶åŒºï¼‰
- Base64URL ç¼–ç æ˜¯å¦æ­£ç¡®ï¼ˆå¦‚æœæœ‰æ‰‹åŠ¨å®ç°ï¼‰

### 4. å¯†ç éªŒè¯æ€»æ˜¯å¤±è´¥

**æ£€æŸ¥ç‚¹ï¼š**

- å“ˆå¸Œç®—æ³•æ˜¯å¦ä¸€è‡´ï¼ˆSHA-256 vs BCryptï¼‰
- ç›çš„å­˜å‚¨å’Œæå–æ˜¯å¦æ­£ç¡®
- å­—ç¬¦ä¸²ç¼–ç é—®é¢˜ï¼ˆUTF-8ï¼‰

---

## ğŸ§ª æµ‹è¯•å»ºè®®

åˆ›å»ºç®€å•çš„æµ‹è¯•ç¨‹åºéªŒè¯å·¥å…·ç±»ï¼š

```cpp
// test_utils.cppï¼ˆä¸´æ—¶æµ‹è¯•æ–‡ä»¶ï¼‰
#include "utils/JwtUtil.h"
#include "utils/PasswordUtils.h"
#include <iostream>

int main() {
    // æµ‹è¯•å¯†ç å“ˆå¸Œ
    std::string password = "test123";
    std::string hash = PasswordUtils::hashPassword(password);
    std::cout << "Hash: " << hash << std::endl;
    
    bool valid = PasswordUtils::verifyPassword(password, hash);
    std::cout << "Verify: " << (valid ? "OK" : "FAIL") << std::endl;
    
    // æµ‹è¯• JWT
    std::string secret = "my-secret-key";
    std::string token = JwtUtil::generateToken(123, secret, 3600);
    std::cout << "Token: " << token << std::endl;
    
    bool tokenValid = JwtUtil::verifyToken(token, secret);
    std::cout << "Token valid: " << (tokenValid ? "OK" : "FAIL") << std::endl;
    
    int userId = JwtUtil::getUserIdFromToken(token);
    std::cout << "User ID: " << userId << std::endl;
    
    return 0;
}
```

---

## ğŸ“š å‚è€ƒèµ„æº

- **jwt-cpp æ–‡æ¡£**ï¼š<https://github.com/Thalhammer/jwt-cpp>
- **OpenSSL SHA-256**ï¼š`man SHA256` æˆ–æŸ¥çœ‹ OpenSSL æ–‡æ¡£
- **Drogon æ•°æ®åº“**ï¼š<https://drogon.docsforge.com/master/pages/09-7-Database/>

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

- [ ] JwtUtil.cc å®ç°å®Œæ•´ï¼ˆç”Ÿæˆ/éªŒè¯/è§£æï¼‰
- [ ] PasswordUtils.cc å®ç°å®Œæ•´ï¼ˆå“ˆå¸Œ/éªŒè¯ï¼‰
- [ ] DbUtils.cc å®ç°åŸºæœ¬åŠŸèƒ½
- [ ] CMakeLists.txt å·²æ·»åŠ å·¥å…·ç±»æ–‡ä»¶
- [ ] ç¼–è¯‘é€šè¿‡
- [ ] ç®€å•æµ‹è¯•éªŒè¯åŠŸèƒ½æ­£å¸¸

**å¼€å§‹å®ç°å§ï¼é‡åˆ°å…·ä½“ç¼–è¯‘é”™è¯¯æˆ–è¿è¡Œæ—¶é—®é¢˜ï¼Œéšæ—¶é—®æˆ‘ï¼** ğŸš€
